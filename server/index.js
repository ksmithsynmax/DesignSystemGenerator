import { createServer } from "http";
import { WebSocketServer } from "ws";
import { spawn } from "child_process";
import { writeFileSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const PROJECT_ROOT = join(__dirname, "..");

const PORT = 9001;
const STORYBOOK_PORT = 6006;

// ---------------------------------------------------------------------------
// HTTP server (handles REST endpoints + upgrades to WebSocket)
// ---------------------------------------------------------------------------

let storybookProcess = null;
let storybookReady = false;

const server = createServer((req, res) => {
  // CORS headers
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type");

  if (req.method === "OPTIONS") {
    res.writeHead(204);
    res.end();
    return;
  }

  // POST /api/launch-storybook
  if (req.method === "POST" && req.url === "/api/launch-storybook") {
    let body = "";
    req.on("data", (chunk) => (body += chunk));
    req.on("end", async () => {
      try {
        const { brands, globalPrimitives } = JSON.parse(body);

        // Write brand data snapshot for Storybook to consume
        const dataContent = `// Auto-generated by Design System Generator — do not edit manually.\n// This file is overwritten each time "Launch Storybook" is clicked.\nexport const GLOBAL_PRIMITIVES = ${JSON.stringify(globalPrimitives, null, 2)};\n\nexport const STORYBOOK_BRANDS = ${JSON.stringify(brands, null, 2)};\n`;

        const dataPath = join(PROJECT_ROOT, "src", "data", "storybookBrands.js");
        writeFileSync(dataPath, dataContent, "utf-8");
        console.log("[storybook] Wrote brand data to storybookBrands.js");

        // If Storybook is already running, just respond (HMR will pick up changes)
        if (storybookProcess && storybookReady) {
          res.writeHead(200, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ url: `http://localhost:${STORYBOOK_PORT}` }));
          return;
        }

        // If a process exists but isn't ready yet, wait for it
        if (storybookProcess && !storybookReady) {
          await waitForStorybook();
          res.writeHead(200, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ url: `http://localhost:${STORYBOOK_PORT}` }));
          return;
        }

        // Spawn Storybook
        console.log("[storybook] Starting Storybook...");
        storybookProcess = spawn("npx", ["storybook", "dev", "-p", String(STORYBOOK_PORT), "--no-open"], {
          cwd: PROJECT_ROOT,
          stdio: ["ignore", "pipe", "pipe"],
          shell: true,
        });

        storybookProcess.stdout.on("data", (data) => {
          const text = data.toString();
          process.stdout.write(`[storybook] ${text}`);
          if (text.includes("localhost") || text.includes("Local:")) {
            storybookReady = true;
          }
        });

        storybookProcess.stderr.on("data", (data) => {
          process.stderr.write(`[storybook:err] ${data.toString()}`);
        });

        storybookProcess.on("close", (code) => {
          console.log(`[storybook] Process exited with code ${code}`);
          storybookProcess = null;
          storybookReady = false;
        });

        // Wait for Storybook to be ready
        await waitForStorybook();

        res.writeHead(200, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ url: `http://localhost:${STORYBOOK_PORT}` }));
      } catch (err) {
        console.error("[storybook] Error:", err.message);
        res.writeHead(500, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ error: err.message }));
      }
    });
    return;
  }

  // GET /api/storybook-status
  if (req.method === "GET" && req.url === "/api/storybook-status") {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ running: !!storybookProcess, ready: storybookReady }));
    return;
  }

  // 404 for other HTTP requests
  res.writeHead(404);
  res.end("Not found");
});

async function waitForStorybook(maxWait = 60000) {
  const start = Date.now();
  while (Date.now() - start < maxWait) {
    if (storybookReady) return;
    // Also try polling the port
    try {
      const response = await fetch(`http://localhost:${STORYBOOK_PORT}`);
      if (response.ok) {
        storybookReady = true;
        return;
      }
    } catch {
      // not ready yet
    }
    await new Promise((r) => setTimeout(r, 1000));
  }
  throw new Error("Storybook did not start within 60 seconds");
}

// ---------------------------------------------------------------------------
// WebSocket relay (Figma sync — unchanged)
// ---------------------------------------------------------------------------

const wss = new WebSocketServer({ server });

const clients = { react: null, plugin: null };

wss.on("connection", (ws) => {
  let role = null;

  ws.on("message", (raw) => {
    let msg;
    try {
      msg = JSON.parse(raw.toString());
    } catch {
      return;
    }

    // Registration message
    if (msg.type === "register") {
      role = msg.role;
      clients[role] = ws;
      console.log(`[relay] ${role} connected`);

      // Notify the other side
      const otherRole = role === "react" ? "plugin" : "react";
      if (clients[otherRole] && clients[otherRole].readyState === 1) {
        clients[otherRole].send(JSON.stringify({ type: "peer-connected", peer: role }));
        ws.send(JSON.stringify({ type: "peer-connected", peer: otherRole }));
      }
      return;
    }

    // Forward to the other role
    const target = role === "react" ? clients.plugin : clients.react;
    if (target && target.readyState === 1) {
      target.send(raw.toString());
    } else {
      ws.send(JSON.stringify({
        type: "error",
        message: `No ${role === "react" ? "plugin" : "react"} connected`,
      }));
    }
  });

  ws.on("close", () => {
    if (role && clients[role] === ws) {
      clients[role] = null;
      console.log(`[relay] ${role} disconnected`);
      const otherRole = role === "react" ? "plugin" : "react";
      if (clients[otherRole] && clients[otherRole].readyState === 1) {
        clients[otherRole].send(JSON.stringify({ type: "peer-disconnected", peer: role }));
      }
    }
  });
});

server.listen(PORT, () => {
  console.log(`[relay] Server listening on http://localhost:${PORT} (HTTP + WebSocket)`);
});
